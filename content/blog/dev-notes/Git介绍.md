---
title: 'Git 介绍'
slug: 'git-introduction'
description: 'Git 介绍。'
category: 'dev-notes'
createtime: '2023-08-23 10.27'
cover: '/images/content/cover/git.gif'
---

# Git 介绍

Git - 分布式版本控制工具

#### 1 开发中 git 的实际应用场景

- 备份
- 代码还原
- 协同开发
- 追溯问题代码的编写人和编写时间

#### 2 版本控制器的方式

- 集中式版本控制工具

  集中式版本控制工具，版本库是集中存放在中央服务器的，team 里每个人 work 时从中央服务器下载代码，是必须联网才能工作，局域网或互联网。个人修改后然后提交到中央版本库。

  举例：SVN 和 CVS

- 分布式版本控制工具

  分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样工作的时候，无需要联网了，因为版本库就在你自己的电脑上。多人协作只需要各自的修改推送给对方，就能互相看到对方的修改了。

  举例：git

#### 3 Git 环境配置

##### 3.1 基本配置

###### 设置用户信息

`git config --global user.name "xxx"`

`git config --global user.email xxx`

###### 查看配置信息

`git config --global user.name`

`git config --global user.email`

##### 3.2 为常用指令配置别名（可选）

1. 打开用户目录，创建 `.bashrc` 文件

   部分 windows 系统不允许用户创建点号开头的文件，可以打开 gitBash ，执行 `touch ~/.bashrc`

2. 在 `.bashrc` 文件中输入如下内容：

   ```bash
   # 用于输出 git 提交信息
   alias git-log='git log --pretty=oneline --all --graph --abbrev-commit'
   # 用于输出当前目录所有文件及基本信息
   alias ll='ls -al'
   ```

3. 打开 gitBash ，执行 `source ~/.bashrc`

##### 3.3 解决 GitBash 乱码问题

1. 打开 GitBash 执行下面命令

   ```bash
   git config --global core.quotepath false
   ```

2. `${git_home}/etc/bash.bashrc` 文件最后加入下面两行

   ```bash
   export LANG="zh_CN.UTF-8"
   export LC_ALL="zh_CN.UTF-8"
   ```

#### 4 获取本地仓库

要使用 Git 对我们的代码进行版本控制，首先需要获得本地仓库

1. 在电脑的任意位置创建一个空目录（例如 test）作为我们的本地 Git 仓库
2. 进入这个目录，点击右键打开 Git Bash 窗口
3. 执行命令 `git init`
4. 如果创建成功后可在文件夹下看到隐藏的 `.git` 目录

#### 5 基础操作指令

Git 工作目录下对于文件的修改（增加、删除、更新）会存在几个状态，这些修改的状态会随着我们执行 Git 的命令而发生变化

仓库（repository）—— 暂存区（index）—— 工作区（workspace）

新创建一个文件（未跟踪untracked）、修改已有文件（未暂存unstaged）：都存在工作区

已暂存（staged）文件：存在于暂存区

修改进入到仓库就变成了一次提交记录

本章节主要讲解如何使用命令来控制这些状态之间的转换：

1. `git add` （工作区 --> 暂存区）
2. `git commit` （暂存区 --> 本地仓库）

##### 5.1 *查看修改的状态（status）

- 作用：查看修改的状态（暂存区、工作区）
- 命令形式：`git status`

##### 5.2 *添加工作区到暂存区（add）

- 作用：添加工作区一个或多个文件的修改到暂存区
- 命令形式：`git add 单个文件名|通配符`
  - 将所有修改加入暂存区：`git add .`

##### 5.3 *提交暂存区到本地仓库（commit）

- 作用：提交暂存区内容到本地仓库的当前分支
- 命令形式：`git commit -m '注释内容'`

##### 5.4 *查看提交日志（log）

在之前配置的别名 `git-log` 就包含了这些参数，所以后续可以直接使用指令 `git-log`

- 作用：查看提交记录
- 命令形式：`git log [option]`
  - options
    - `--all` 显示所有分支
    - `--pretty=oneline` 将提交信息显示为一行
    - `--abbrev-commit` 使得输出的 committId 更简短
    - `--graph` 以图的形式显示

##### 5.5 版本回退

- 作用：版本切换
- 命令形式：`git reset --hard commitID`
  - commitID 可以使用 `git-log` 或 `git log` 指令查看
- 如何查看已经删除的记录？
  - `git reflog` 这个指令可以看到已经删除的提交记录

##### 5.6 添加文件至忽略列表

一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以在工作目录中创建一个名为 `.gitignore` 的文件（文件名称固定），列出要忽略的文件模式。下面是一个示例：

```bash
#               表示此为注释,将被Git忽略
*.a             表示忽略所有 .a 结尾的文件
!lib.a          表示但lib.a除外
/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
build/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；
doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt
 
bin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件
/bin:           表示忽略根目录下的bin文件
/*.c:           表示忽略cat.c，不忽略 build/cat.c
debug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj
**/foo:         表示忽略/foo,a/foo,a/b/foo等
a/**/b:         表示忽略a/b, a/x/b,a/x/y/b等
!/bin/run.sh    表示不忽略bin目录下的run.sh文件
*.log:          表示忽略所有 .log 文件
config.php:     表示忽略当前路径的 config.php 文件
 
/mtk/           表示过滤整个文件夹
*.zip           表示过滤所有.zip文件
/mtk/do.c       表示过滤某个具体文件
 
被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。
 
需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：
!*.zip
!/mtk/one.txt
 
唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？
想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：
/mtk/*
!/mtk/one.txt
 
假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！
注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！
 
----------------------------------------------------------------------------------
还有一些规则如下：
fd1/*
说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；
 
/fd1/*
说明：忽略根目录下的 /fd1/ 目录的全部内容；
 
/*
!.gitignore
!/fw/ 
/fw/*
!/fw/bin/
!/fw/sf/
说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。
```

#### 6 分支

几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的 bug 修改、开发新的功能，以免影响开发主线。

##### 6.1 查看本地分支

命令：`git branch`

##### 6.2 创建本地分支

命令：`git branch 分支名`

##### 6.3 *切换分支（checkout）

命令：`git checkout 分支名`

我们还可以直接切换到一个不存在的分支（创建并切换）

命令：`git checkout -b 分支名`

##### 6.4 *合并分支（merge）

一个分支上的提交可以合并到另一个分支

命令：`git merge 分支名称`

##### 6.5 删除分支

**不能删除当前分支，只能删除其它分支**

`git branch -d b1` 删除分支时，需要做各种检查

`git branch -D b1` 不做任何检查，强制删除

##### 6.6 解决冲突

两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下：

1. 处理文件中冲突的地方
2. 将解决完冲突的文件加入暂存区（add）
3. 提交到仓库（commit）

##### 6.7 开发中分支使用原则与流程

几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的 Bug 修改、开发新的功能，以免影响开发主线。

在开发中，一般有如下分支使用原则：

- master （生产）分支

  线上分支，主分支，中小规模项目作为线上运行的应用对应的分支；

- develop （开发）分支

  是从 master 创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线要求，都可以在此版本进行开发，阶段开发完成后，需要合并到 master 分支准备上线。

- feature/xxxx 分支

  从 develop 创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完成后合并到 develop 分支。

- hotfix/xxxx 分支

  从 master 派生的分支，一般作为线上 bug 修复使用，修复完成后需要合并到 master、test、develop 分支。

- 还有一些其他分支，例如 test 分支（用于代码测试）、pre分支（预上线分支）等等。

#### 7 Git 远程仓库

##### 7.1 常用的托管服务[远程仓库]

- gitHub：面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 gitHub
- 码云：国内的一个代码托管平台，由于服务器在国内，所以相比于 GitHub，码云速度会更快
- GitLab：用于仓库管理系统的开源项目，使用 Git 作为代码管理工具，并在此基础上搭建起来的 web 项目，一般由于在企业、学校等内部网络搭建 git 私服。

##### 7.2 创建远程仓库

##### 7.3 配置 SSH 公钥

- 生成 SSH 公钥
  - `ssh-keygen -t rsa`
  - 不断回车
    - 如果公钥已经存在，则自动覆盖
- Gitee 设置账户公钥
  - 获取公钥
    - `cat ~/.ssh/id_rsa.pub`
  - 在 Gitee 相关页面配置公钥
  - 验证是否配置成功
    - `ssh -T git@gitee.com`

##### 7.4 操作远程仓库

###### 7.4.1 添加远程仓库

**此操作是先初始化本地仓库，然后与已创建的远程仓库进行对接。**

- 命令：`git remote add <远端名称> <仓库路径>
  - 远端名称，默认是 origin ，取决于远端服务器设置
  - 仓库路径，从远端服务器获取此 URL
    - 例如：`git remote add origin git@gitee.com:zhang-jingpeng2000/zhangjingpeng_test.git`

###### 7.4.2 查看远程仓库

- 命令：`git remote`

###### 7.4.3 推送到远程仓库

- 命令：`git push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名]]`
  - 如果远程分支名和本地分支名称相同，则可以只写本地分支
    - `git push origin master`
  - `-f` 表示强制覆盖
  - `--set-upstream` 推送到远端的同时并且建立起和远端分支的关联关系
    - `git push --set-upstream origin master`
  - 如果**当前分支已经和远端分支关联**，则可以省略分支名和远端名。
    - `git push` 将 master 分支推送到已关联的远端分支。

###### 7.4.4 本地分支与远程分支的关联关系

- 查看关联关系我们可以使用 `git branch -vv` 命令

###### 7.4.5 从远程仓库克隆

如果已经有一个远程仓库，我们可以直接 clone 到本地。

- 命令：`git clone <仓库路径> [本地目录]`
  - 本地目录可以省略，会自动生成一个目录

###### 7.4.6 从远程仓库中抓取和拉取

远程分支和本地的分支一样，我们可以进行 merge 操作，只是需要先把远端仓库都下载到本地，再进行操作。

- 抓取 命令：`git fetch [remote name] [branch name]`
  - **抓取指令就是将仓库里的更新都抓取到本地，不会进行合并**
  - 如果不指定远端名称和分支名，则抓取所有分支
- 拉取 命令：`git pull [remote name] [branch name]`
  - **拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于 fetch + merge**
  - 如果不指定远端名称和分支名，则抓取所有并更新到当前分支。

###### 7.4.7 解决合并冲突

在同一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。

A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，**故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支**。

在B用户拉取代码时，因为A、B用户同一段时间修改了同一个文件的相同位置代码，故会发生合并冲突。

**远程分支也是分支，所以合并时冲突的解决问题也和解决本地冲突相同**。